#!/usr/bin/env ruby
#
# rexe - Ruby Command Line Executor Filter
#
# Inspired by https://github.com/thisredone/rb


require 'optparse'
require 'shellwords'

# Rexe - Ruby Executor
class Rexe < Struct.new(:input_mode, :loads, :requires, :verbose)

  VERSION = '0.3.1'

  def initialize
    self.input_mode = :string
    self.loads = []
    self.requires = []
    self.verbose = false
  end


  def help_text
    <<~HEREDOC

    rexe -- Ruby Command Line Filter -- v#{VERSION} -- https://github.com/keithrbennett/rexe

    Optionally takes standard input and runs the specified code on it, sending the result to standard output.

    Options:

    -h, --help               Print help and exit
    -l, --load RUBY_FILE(S)  Ruby file(s) to load, comma separated
    -m, --mode MODE          Mode with which to handle input (i.e. what `self` will be in the code):
                               -ms for each line to be handled separately as a string (default)
                               -me for an enumerator of lines (least memory consumption for big data)
                               -mb for 1 big string (all lines combined into single multiline string)
                               -mn to execute the specified Ruby code on no input at all 
    -r, --require REQUIRES   Gems and built-in libraries (e.g. shellwords, yaml) to require, comma separated
    -v, --[no-]verbose       Verbose mode (logs to stderr)

    If there is an .rexerc file in your home directory, it will be run as Ruby code 
    before processing the input.

    If there is an REXE_OPTIONS environment variable, its content will be prepended to the command line
    so that you can specify options implicitly (e.g. `export REXE_OPTIONS="-r awesome_print,yaml"`)

    HEREDOC
  end


  def prepend_environment_options
    env_opt_string = ENV['REXE_OPTIONS']
    if env_opt_string
      args_to_prepend = Shellwords.shellsplit(env_opt_string)
      ARGV.unshift(args_to_prepend).flatten!
    end
  end


  def parse_command_line
    prepend_environment_options

    add_comma_sep_tokens_to_array = ->(string, array) do
      string.split(',').map(&:strip).each { |r| array << r }
    end

    OptionParser.new do |parser|

      parser.on("-h", "--help", "Show help") do |_help_requested|
        puts help_text
        exit
      end

      parser.on('-l', '--load RUBY_FILE(S)', 'Ruby file(s) to load, comma separated') do |v|
        add_comma_sep_tokens_to_array.(v, self.loads)
      end

      parser.on('-m', '--mode MODE',
                'Mode with which to handle input (-ms (default), -me, -mb, mn)') do |v|

        modes = {
            's' => :string,
            'e' => :enumerator,
            'b' => :one_big_string,
            'n' => :no_input
        }

        self.input_mode = modes[v]
        if self.input_mode.nil?
          puts help_text
          raise "Input mode must be one of #{modes.keys}."
        end
      end

      parser.on('-r', '--require REQUIRE(S)',
                'Gems and built-in libraries (e.g. shellwords, yaml) to require, comma separated') do |v|
        add_comma_sep_tokens_to_array.(v, self.requires)
      end

      parser.on('-v', '--[no-]verbose', 'Verbose mode (logs to stderr)') do |v|
        self.verbose = v
      end
    end.parse!
  end


  def load_global_config_if_exists
    filespec = File.join(Dir.home, '.rexerc')
    exists = File.exists?(filespec)
    if exists
      log_if_verbose("Loading global config file #{filespec}")
      load(filespec)
    end
    exists ? filespec : nil
  end


  def execute(eval_context_object, code)
    if eval_context_object
      puts eval_context_object.instance_eval(&code)
    else
      puts code.call
    end
  rescue Errno::EPIPE
    exit(-13)
  end


  def log_if_verbose(string)
    STDERR.puts(string) if verbose
  end


  def call
    start_time = Time.now

    parse_command_line

    log_if_verbose("rexe version #{VERSION} -- #{Time.now}")
    log_if_verbose('Source Code: ' + ARGV.join(' '))
    log_if_verbose('Options: ' + self.to_h.to_s)

    requires.each do |r|
      require(r)
    end

    load_global_config_if_exists

    loads.each do |file|
      load(file)
    end

    source_code = "Proc.new { #{ARGV.join(' ')} }"
    code = eval(source_code)

    actions = {
        string:         -> { STDIN.each { |l| execute(l.chomp, code) } },
        enumerator:     -> { execute(STDIN.each_line, code) },
        one_big_string: -> { big_string = STDIN.each_line.to_a.join; execute(big_string, code) },
        no_input:       -> { execute(nil, code) }
    }

    actions[input_mode].()

    duration = Time.now - start_time
    log_if_verbose("rexe time elapsed: #{duration} seconds.")
  end
end

# This is needed because the gemspec file loads this file to access Rexe::VERSION
# and must not have it run at that time:
called_as_script = (File.basename($0) == File.basename(__FILE__))
Rexe.new.call if called_as_script
