#!/usr/bin/env ruby
#
# rexe - Ruby Command Line Executor Filter
#
# Inspired by https://github.com/thisredone/rb

require 'bundler'
require 'date'
require 'optparse'
require 'ostruct'
require 'shellwords'

class Rexe < Struct.new(:input_format, :input_mode, :loads, :output_format, :requires, :verbose, :noop)

  VERSION = '0.11.0'


  def initialize
    clear_options
  end


  def input_modes
    @input_modes ||= {
        'l' => :line,
        'e' => :enumerator,
        'b' => :one_big_string,
        'n' => :no_input
    }
  end


  def input_formats
    @input_formats ||=  {
        'j' => :json,
        'm' => :marshal,
        'n' => :none,
        'y' => :yaml,
    }
  end


  def input_parsers
    @input_parsers ||= {
        json:    ->(obj)  { JSON.parse(obj) },
        marshal: ->(obj)  { Marshal.load(obj) },
        none:    ->(obj)  { obj },
        yaml:    ->(obj)  { YAML.load(obj) },
    }
  end


  def output_formats
    @output_formats ||= {
        'a' => :awesome_print,
        'i' => :inspect,
        'j' => :json,
        'J' => :pretty_json,
        'm' => :marshal,
        'n' => :no_output,
        'p' => :puts,         # default
        'P' => :pretty_print,
        's' => :to_s,
        'y' => :yaml,
    }
  end


  def formatters
    @formatters ||=  {
        awesome_print: ->(obj)  { obj.ai },
        inspect:       ->(obj)  { obj.inspect + "\n" },
        json:          ->(obj)  { obj.to_json },
        marshal:       ->(obj)  { Marshal.dump(obj) },
        no_output:     ->(_obj) { nil },
        pretty_json:   ->(obj)  { JSON.pretty_generate(obj) },
        pretty_print:  ->(obj)  { obj.pretty_inspect },
        puts:          ->(obj)  { sio = StringIO.new; sio.puts(obj); sio.string },   # default
        to_s:          ->(obj)  { obj.to_s + "\n" },
        yaml:          ->(obj)  { obj.to_yaml },
    }
  end


  def parser_and_format_requires
    @format_requires ||= {
        json:          'json',
        pretty_json:   'json',
        awesome_print: 'awesome_print',
        pretty_print:  'pp',
        yaml:          'yaml'
    }
  end


  # Used as an initializer and also when `-!` is specified on the command line.
  def clear_options
    self.input_format = :none
    self.input_mode = :no_input
    self.output_format = :puts
    self.loads = []
    self.requires = []
    self.verbose = false
    self.noop = false
    @output_formatter = nil
  end


  def help_text
    <<~HEREDOC

    rexe -- Ruby Command Line Executor/Filter -- v#{VERSION} -- https://github.com/keithrbennett/rexe

    Executes Ruby code on the command line, optionally taking standard input and writing to standard output.

    rexe [options] 'Ruby source code'

    Options:

    -c  --clear_options        Clear all previous command line options specified up to now
    -h, --help                 Print help and exit
    -i, --input_format FORMAT  Input format (none is default)
                                 -ij  JSON
                                 -im  Marshal
                                 -in  None
                                 -iy  YAML
    -l, --load RUBY_FILE(S)    Ruby file(s) to load, comma separated, or ! to clear
    -m, --input_mode MODE      Mode with which to handle input (i.e. what `self` will be in your code):
                                 -ml  line mode; each line is ingested as a separate string
                                 -me  enumerator mode
                                 -mb  big string mode; all lines combined into single multiline string
                                 -mn  (default) no input mode; no special handling of input; self is an Object.new 
    -n, --[no-]noop            Do not execute the code (useful with -v); see note (1) below
    -o, --output_format FORMAT Output format (puts is default):
                                 -oi  Inspect
                                 -oj  JSON
                                 -oJ  Pretty JSON
                                 -om  Marshal
                                 -on  No Output
                                 -op  Puts (default)
                                 -os  to_s
                                 -oy  YAML
    -r, --require REQUIRE(S)   Gems and built-in libraries to require, comma separated, or ! to clear
    -v, --[no-]verbose         verbose mode (logs to stderr); see note (1) below

    If there is an .rexerc file in your home directory, it will be run as Ruby code 
    before processing the input.

    If there is a REXE_OPTIONS environment variable, its content will be prepended to the command line
    so that you can specify options implicitly (e.g. `export REXE_OPTIONS="-r awesome_print,yaml"`)

    (1) For boolean 'verbose' and 'noop' options, the following are valid:
    -v no, -v yes, -v false, -v true, -v n, -v y, -v +, but not -v -

    HEREDOC
  end


  def prepend_environment_options
    env_opt_string = ENV['REXE_OPTIONS']
    if env_opt_string
      args_to_prepend = Shellwords.shellsplit(env_opt_string)
      ARGV.unshift(args_to_prepend).flatten!
    end
  end


  def parse_command_line

    OptionParser.new do |parser|

      parser.on("-h", "--help", "Show help") do |_help_requested|
        puts help_text
        exit
      end

      parser.on('-i', '--input_format FORMAT',
                'Mode with which to parse input values (n = none (default), j = JSON, m = Marshal, y = YAML') do |v|

        self.input_format = input_formats[v]
        if self.input_format.nil?
          puts help_text
          raise "Input mode was '#{v}' but must be one of #{input_formats.keys}."
        end
      end

      parser.on('-l', '--load RUBY_FILE(S)', 'Ruby file(s) to load, comma separated, or ! to clear') do |v|
        if v == '!'
          self.loads.clear
        else
          loadfiles = v.split(',').map(&:strip)
          existent, nonexistent = loadfiles.partition { |filespec| File.exists?(filespec) }
          if nonexistent.any?
            raise("\nDid not find the following files to load: #{nonexistent.to_s}\n\n")
          else
            existent.each { |filespec| self.loads << filespec }
          end
        end
      end

      parser.on('-m', '--input_mode MODE',
                'Mode with which to handle input (-ml, -me, -mb, -mn (default)') do |v|

        self.input_mode = input_modes[v]
        if self.input_mode.nil?
          puts help_text
          raise "Input mode was '#{v}' but must be one of #{input_modes.keys}."
        end
      end

      parser.on('-o', '--output_format FORMAT',
                'Mode with which to format values for output (`-o` + [aijJmnpsy])') do |v|

        self.output_format = output_formats[v]
        if self.output_format.nil?
          puts help_text
          raise "Output mode was '#{v}' but must be one of #{output_formats.keys}."
        end
      end

      parser.on('-r', '--require REQUIRE(S)',
                'Gems and built-in libraries (e.g. shellwords, yaml) to require, comma separated, or ! to clear') do |v|
        if v == '!'
          self.requires.clear
        else
          v.split(',').map(&:strip).each { |r| self.requires << r }
        end
      end

      # See https://stackoverflow.com/questions/54576873/ruby-optionparser-short-code-for-boolean-option
      # for an excellent explanation of this optparse incantation.
      # According to the answer, valid options are:
      # -v no, -v yes, -v false, -v true, -v n, -v y, -v +, but not -v -.
      parser.on('-v', '--[no-]verbose [FLAG]', TrueClass, 'Verbose mode (logs to stderr)') do |v|
        self.verbose = (v.nil? ? true : v)
      end

      parser.on('-c', '--clear_options', "Clear all previous command line options") do |v|
        clear_options
      end

      parser.on('-n', '--[no-]noop [FLAG]', TrueClass, "Do not execute the code (useful with -v)") do |v|
        self.noop = (v.nil? ? true : v)
      end

      parser.on('', '--version', 'Print version') do
        puts VERSION
        exit
      end
    end.parse!

    requires.uniq!
    loads.uniq!

  end


  def load_global_config_if_exists
    filespec = File.join(Dir.home, '.rexerc')
    load(filespec) if File.exists?(filespec)
  end


  def execute(eval_context_object, code)
    if input_format != :none && input_mode != :no_input
      eval_context_object = input_parser.(eval_context_object)
    end

    value = eval_context_object.instance_eval(&code)
    unless output_format == :no_output
      print output_formatter.(value)
    end
  rescue Errno::EPIPE
    exit(-13)
  end


  def call
    start_time = DateTime.now

    prepend_environment_options
    parse_command_line
    user_source_code = ARGV.join(' ')

    requires.each { |r| require(r) }
    load_global_config_if_exists
    loads.each { |file| load(file) }

    callable = eval("Proc.new { #{user_source_code} }")

    actions = {
        line:           -> { STDIN.each { |l| execute(l.chomp, callable);            $RC[:count] += 1 } },
        enumerator:     -> { execute(STDIN.each_line, callable);                     $RC[:count] += 1 },
        one_big_string: -> { big_string = STDIN.read; execute(big_string, callable); $RC[:count] += 1 },
        no_input:       -> { execute(Object.new, callable) }
    }

    # This global $RC (Rexe Context) OpenStruct is available in your user code.
    # In order to make it possible to access this hash in your loaded files, we are not initializing
    # the hash here; instead we add key/value pairs to it. This way, you can initialize a hash yourself
    # in your loaded code.
    $RC ||= OpenStruct.new
    $RC.count         = 0
    $RC.rexe_version  = VERSION
    $RC.start_time    = start_time.iso8601
    $RC.source_code   = user_source_code
    $RC.options       = self.to_h

    actions[input_mode].() unless self.noop

    if verbose
      $RC.duration_secs = Time.now - start_time.to_time
      require 'yaml'
      STDERR.puts($RC.to_h.to_yaml)
    end
  end
end


def input_parser
  if @input_parser.nil?
    require_spec = parser_and_format_requires[input_format]
    require require_spec if require_spec
    @input_parser = input_parsers[input_format]
  end
  @input_parser
end


def output_formatter
  if @output_formatter.nil?
    require_spec = parser_and_format_requires[output_format]
    require require_spec if require_spec
    @output_formatter = formatters[output_format]
  end
  @output_formatter
end


# This is needed because the gemspec file loads this file to access Rexe::VERSION
# and must not have it run at that time:
called_as_script = (File.basename($0) == File.basename(__FILE__))
if called_as_script
  Bundler.with_clean_env { Rexe.new.call }
end
