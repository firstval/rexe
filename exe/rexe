#!/usr/bin/env ruby
#
# rexe - Ruby Command Line Executor Filter
#
# Inspired by https://github.com/thisredone/rb


require 'optparse'
require 'shellwords'

# Rexe - Ruby Executor
class Rexe < Struct.new(:line_mode, :loads, :requires, :verbose)

  VERSION = '0.0.2'

  def initialize
    self.line_mode = :string
    self.loads = []
    self.requires = []
    self.verbose = false
  end


  def help_text
    <<~HEREDOC

    rexe -- Ruby Command Line Filter -- v#{VERSION} -- https://github.com/keithrbennett/rexe

    Takes standard input and runs the specified code on it, sending the result to standard output.
    Your Ruby code can operate on each line individually (-ms) (the default),
    or operate on the enumerator of all lines (-me). If the latter, you will probably need to
    call chomp on the lines yourself to remove the trailing newlines.

    Options:

    -h, --help               Print help and exit
    -l, --load               Load this Ruby source code file
    -m, --mode MODE          Mode with which to handle input (i.e. what `self` will be in the code):
                               -ms for each line to be handled separately as a string (default)
                               -me for an enumerator of lines (least memory consumption for big data)
                               -mb for 1 big string (all lines combined into single multiline string)
    -r, --require REQUIRES   Gems and built-in libraries (e.g. shellwords, yaml) to require, comma separated
    -v, --[no-]verbose       Verbose mode, writes to stderr

    If there is an .rexerc file in your home directory, it will be run as Ruby code before processing the input.

    If there is an REXE_OPTIONS environment variable, its content will be prepended to the command line
    so that you can specify options implicitly (e.g. `export REXE_OPTIONS="-r awesome_print,yaml"`)

    HEREDOC
  end


  def prepend_environment_options
    env_opt_string = ENV['REXE_OPTIONS']
    if env_opt_string
      args_to_prepend = Shellwords.shellsplit(env_opt_string)
      ARGV.unshift(args_to_prepend).flatten!
    end
  end


  def parse_command_line
    prepend_environment_options

    OptionParser.new do |parser|

      parser.on("-h", "--help", "Show help") do |_help_requested|
        puts help_text
        exit
      end

      parser.on('-l', '--load RUBY_FILE', 'Loads and runs this Ruby file') do |v|
        self.loads << v
      end

      parser.on('-m', '--mode MODE',
                'Mode with which to handle input (-ms for string (default), -me for enumerator)') do |v|
        self.line_mode = case v
                         when 's'
                           self.line_mode = :string
                         when 'e'
                           self.line_mode = :enumerator
                         when 'b'
                           self.line_mode = :one_big_string
                         else
                           puts "Mode must be either 's' for string, 'e' for enumerator, or 'b' for 1 big string."
                           exit -1
                         end
      end

      parser.on('-r', '--require REQUIRES', 'Gems and modules to require, comma separated') do |v|
        v.split(',').map(&:strip).each { |r| self.requires << r }
      end

      parser.on('-v', '--[no-]verbose', 'Verbose mode') do |v|
        self.verbose = v
      end
    end.parse!
  end


  def load_global_config_if_exists
    filespec = File.join(Dir.home, '.rexerc')
    exists = File.exists?(filespec)
    load(filespec) if exists
    exists ? filespec : nil
  end


  def execute(line_or_enumerator, code)
    puts line_or_enumerator.instance_eval(&code)
  rescue Errno::EPIPE
    exit(-13)
  end


  def log_if_verbose(string)
    STDERR.puts(string) if verbose
  end


  def call
    parse_command_line

    log_if_verbose("Requiring #{requires}") if requires.any?
    requires.each { |r| require r }

    filespec = load_global_config_if_exists
    log_if_verbose("Loaded #{filespec}") if filespec

    loads.each { |file| load(file) }

    source_code = "Proc.new { #{ARGV.join(' ')} }"
    log_if_verbose("Source code: #{source_code}")
    code = eval(source_code)

    case line_mode
    when :string
      STDIN.each { |l| execute(l.chomp, code) }
    when :enumerator
      execute(STDIN.each_line, code)
    when :one_big_string
      big_string = STDIN.each_line.to_a.join
      execute(big_string, code)
    end
  end
end

# This is needed because the gemspec file loads this file to access Rexe::VERSION
# and must not have it run at that time:
called_as_script = (File.basename($0) == File.basename(__FILE__))
Rexe.new.call if called_as_script


